<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trapping Rain Water Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .header {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            color: #64b5f6;
        }
        
        .toolbar {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        button {
            padding: 12px 20px;
            font-size: 1rem;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            background: #0d8bf2;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .input-section {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .input-section h2 {
            margin-bottom: 15px;
            color: #64b5f6;
        }
        
        .input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #2196f3;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }
        
        input::placeholder {
            color: #aaa;
        }
        
        .visualization-container {
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100%;
            height: 300px;
            position: relative;
        }
        
        .explanation {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .explanation h2 {
            margin-bottom: 15px;
            color: #64b5f6;
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 15px;
            min-height: 60px;
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .current-pointer {
            background: #ffeb3b;
        }
        
        .left-pointer {
            background: #4caf50;
        }
        
        .right-pointer {
            background: #f44336;
        }
        
        .water {
            background: #2196f3;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 50px;
        }
        
        @media (max-width: 600px) {
            .toolbar {
                flex-wrap: wrap;
            }
            
            button {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .input-container {
                flex-direction: column;
            }
            
            input {
                width: 100%;
            }
            
            .legend {
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        
        <div class="toolbar">
            <button id="prev-btn">
                <i>◀</i> Previous
            </button>
            <button id="play-pause-btn">
                <i>▶</i> Play
            </button>
            <button id="next-btn">
                Next <i>▶</i>
            </button>
        </div>
        
        <div class="input-section">
            <h2>Input Heights</h2>
            <div class="input-container">
                <input type="text" id="height-input" placeholder="Enter heights (e.g. 0,1,0,2,1,0,1,3,2,1,2,1)" value="0,1,0,2,1,0,1,3,2,1,2,1">
                <button id="apply-btn">Apply</button>
            </div>
            <p>Example: [0,1,0,2,1,0,1,3,2,1,2,1] will trap 6 units of water</p>
        </div>
        
        <div class="visualization-container">
            <div id="canvas-container"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color current-pointer"></div>
                    <span>Current Pointer</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color left-pointer"></div>
                    <span>Left Pointer</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color right-pointer"></div>
                    <span>Right Pointer</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color water"></div>
                    <span>Trapped Water</span>
                </div>
            </div>
        </div>
        
        <div class="explanation">
            <h2>Algorithm Explanation</h2>
            <div class="subtitle" id="subtitle">
                Initial state: Setting up pointers and variables
            </div>
            <div class="controls">
                <div class="speed-control">
                    <span>Speed:</span>
                    <button id="speed-down">-</button>
                    <span id="speed-value">2s</span>
                    <button id="speed-up">+</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let heights = [0,1,0,2,1,0,1,3,2,1,2,1];
        let steps = [];
        let currentStep = 0;
        let isPlaying = false;
        let autoPlayInterval;
        let delay = 2000; // 2 seconds
        let sketch;

        // DOM elements
        const prevBtn = document.getElementById('prev-btn');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const nextBtn = document.getElementById('next-btn');
        const applyBtn = document.getElementById('apply-btn');
        const heightInput = document.getElementById('height-input');
        const subtitleElement = document.getElementById('subtitle');
        const speedUpBtn = document.getElementById('speed-up');
        const speedDownBtn = document.getElementById('speed-down');
        const speedValue = document.getElementById('speed-value');

        // Initialize the visualization
        function initVisualization() {
            // Reset steps
            steps = [];
            currentStep = 0;
            
            // Generate steps for the algorithm
            generateSteps();
            
            // Update UI
            updateSubtitle();
            updateButtons();
            
            // Create or update the p5 sketch
            if (sketch) {
                sketch.remove();
            }
            sketch = new p5(trappingRainWaterSketch, 'canvas-container');
        }

        // Generate steps for the two-pointer approach
        function generateSteps() {
            steps = [];
            
            let left = 0;
            let right = heights.length - 1;
            let leftMax = 0;
            let rightMax = 0;
            let trappedWater = 0;
            
            steps.push({
                left: left,
                right: right,
                leftMax: leftMax,
                rightMax: rightMax,
                trappedWater: trappedWater,
                action: "start",
                explanation: "Initialize pointers at both ends of the array"
            });
            
            while (left < right) {
                if (heights[left] < heights[right]) {
                    if (heights[left] >= leftMax) {
                        leftMax = heights[left];
                        steps.push({
                            left: left,
                            right: right,
                            leftMax: leftMax,
                            rightMax: rightMax,
                            trappedWater: trappedWater,
                            action: "updateLeftMax",
                            explanation: `Height at left pointer (${heights[left]}) is greater than leftMax (${leftMax}). Update leftMax to ${heights[left]}.`
                        });
                    } else {
                        trappedWater += leftMax - heights[left];
                        steps.push({
                            left: left,
                            right: right,
                            leftMax: leftMax,
                            rightMax: rightMax,
                            trappedWater: trappedWater,
                            action: "trapWater",
                            explanation: `Trapping ${leftMax - heights[left]} units of water at position ${left}.`
                        });
                    }
                    left++;
                    steps.push({
                        left: left,
                        right: right,
                        leftMax: leftMax,
                        rightMax: rightMax,
                        trappedWater: trappedWater,
                        action: "moveLeft",
                        explanation: "Move left pointer to the right."
                    });
                } else {
                    if (heights[right] >= rightMax) {
                        rightMax = heights[right];
                        steps.push({
                            left: left,
                            right: right,
                            leftMax: leftMax,
                            rightMax: rightMax,
                            trappedWater: trappedWater,
                            action: "updateRightMax",
                            explanation: `Height at right pointer (${heights[right]}) is greater than rightMax (${rightMax}). Update rightMax to ${heights[right]}.`
                        });
                    } else {
                        trappedWater += rightMax - heights[right];
                        steps.push({
                            left: left,
                            right: right,
                            leftMax: leftMax,
                            rightMax: rightMax,
                            trappedWater: trappedWater,
                            action: "trapWater",
                            explanation: `Trapping ${rightMax - heights[right]} units of water at position ${right}.`
                        });
                    }
                    right--;
                    steps.push({
                        left: left,
                        right: right,
                        leftMax: leftMax,
                        rightMax: rightMax,
                        trappedWater: trappedWater,
                        action: "moveRight",
                        explanation: "Move right pointer to the left."
                    });
                }
            }
            
            steps.push({
                left: left,
                right: right,
                leftMax: leftMax,
                rightMax: rightMax,
                trappedWater: trappedWater,
                action: "end",
                explanation: `Algorithm complete. Trapped ${trappedWater} units of water.`
            });
        }

        // Update the subtitle based on current step
        function updateSubtitle() {
            if (steps.length > 0 && currentStep < steps.length) {
                subtitleElement.textContent = steps[currentStep].explanation;
            }
        }

        // Update button states
        function updateButtons() {
            prevBtn.disabled = currentStep <= 0;
            nextBtn.disabled = currentStep >= steps.length - 1;
            
            if (isPlaying) {
                playPauseBtn.innerHTML = '<i>⏸</i> Pause';
            } else {
                playPauseBtn.innerHTML = '<i>▶</i> Play';
            }
        }

        // Move to next step
        function nextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                updateSubtitle();
                updateButtons();
                sketch.redraw();
            }
        }

        // Move to previous step
        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                updateSubtitle();
                updateButtons();
                sketch.redraw();
            }
        }

        // Toggle play/pause
        function togglePlayPause() {
            isPlaying = !isPlaying;
            updateButtons();
            
            if (isPlaying) {
                autoPlayInterval = setInterval(() => {
                    if (currentStep < steps.length - 1) {
                        nextStep();
                    } else {
                        isPlaying = false;
                        clearInterval(autoPlayInterval);
                        updateButtons();
                    }
                }, delay);
            } else {
                clearInterval(autoPlayInterval);
            }
        }

        // Adjust animation speed
        function adjustSpeed(increase) {
            if (increase && delay > 500) {
                delay -= 500;
            } else if (!increase && delay < 5000) {
                delay += 500;
            }
            speedValue.textContent = `${delay/1000}s`;
            
            // If already playing, reset the interval with new delay
            if (isPlaying) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = setInterval(() => {
                    if (currentStep < steps.length - 1) {
                        nextStep();
                    } else {
                        isPlaying = false;
                        clearInterval(autoPlayInterval);
                        updateButtons();
                    }
                }, delay);
            }
        }

        // Event listeners
        prevBtn.addEventListener('click', prevStep);
        nextBtn.addEventListener('click', nextStep);
        playPauseBtn.addEventListener('click', togglePlayPause);
        applyBtn.addEventListener('click', () => {
            const input = heightInput.value.trim();
            if (input) {
                try {
                    const newHeights = input.split(',').map(Number);
                    if (newHeights.length > 0 && newHeights.every(h => !isNaN(h) && h >= 0)) {
                        heights = newHeights;
                        initVisualization();
                        isPlaying = false;
                        clearInterval(autoPlayInterval);
                        updateButtons();
                    } else {
                        alert("Please enter valid non-negative numbers separated by commas");
                    }
                } catch (e) {
                    alert("Invalid input format. Please enter numbers separated by commas.");
                }
            }
        });

        speedUpBtn.addEventListener('click', () => adjustSpeed(true));
        speedDownBtn.addEventListener('click', () => adjustSpeed(false));

        // p5.js Sketch
        function trappingRainWaterSketch(p) {
            let barWidth;
            let maxHeight;
            
            p.setup = function() {
                const canvas = p.createCanvas(p.windowWidth, 300);
                canvas.parent('canvas-container');
                p.colorMode(p.HSB, 400, 100, 50, 1);
                p.textSize(14);
                p.textAlign(p.CENTER, p.BOTTOM);
                
                barWidth = p.width / (heights.length + 2);
                maxHeight = Math.max(...heights);
                if (maxHeight === 0) maxHeight = 1; // Handle all zeros case
                
                p.noLoop();
            };
            
            p.draw = function() {
                if (steps.length === 0 || currentStep >= steps.length) return;
                
                const step = steps[currentStep];
                p.background(30, 30, 10);
                
                // Draw bars
                for (let i = 0; i < heights.length; i++) {
                    const x = (i + 1) * barWidth;
                    const barHeight = (heights[i] / maxHeight) * (p.height - 60);
                    const y = p.height - 30 - barHeight;
                    
                    // Draw bar
                    p.fill(200, 50, 60);
                    p.rect(x - barWidth/3, y, barWidth*2/3, barHeight);
                    
                    // Draw height label
                    p.fill(0, 0, 100);
                    p.text(heights[i], x, p.height - 10);
                }
                
                // Draw pointers
                if (step.left < heights.length) {
                    const leftX = (step.left + 1) * barWidth;
                    p.fill(120, 100, 50); // Green
                    p.triangle(
                        leftX, p.height - 35,
                        leftX - 10, p.height - 15,
                        leftX + 10, p.height - 15
                    );
                }
                
                if (step.right < heights.length) {
                    const rightX = (step.right + 1) * barWidth;
                    p.fill(0, 100, 50); // Red
                    p.triangle(
                        rightX, p.height - 35,
                        rightX - 10, p.height - 15,
                        rightX + 10, p.height - 15
                    );
                }
                
                // Draw trapped water
                let waterLevel = 0;
                for (let i = 0; i < heights.length; i++) {
                    if (i === 0 || i === heights.length - 1) continue;
                    
                    const x = (i + 1) * barWidth;
                    const leftMax = Math.max(...heights.slice(0, i + 1));
                    const rightMax = Math.max(...heights.slice(i));
                    const waterHeight = Math.min(leftMax, rightMax);
                    
                    if (waterHeight > heights[i]) {
                        const barHeight = (heights[i] / maxHeight) * (p.height - 60);
                        const y = p.height - 30 - barHeight;
                        const waterBarHeight = ((waterHeight - heights[i]) / maxHeight) * (p.height - 60);
                        
                        p.fill(220, 80, 70, 0.7); // Blue with transparency
                        p.rect(x - barWidth/3, y - waterBarHeight, barWidth*2/3, waterBarHeight);
                    }
                }
                
                // Draw water level lines for current pointers
                p.stroke(220, 80, 70);
                p.strokeWeight(2);
                p.noFill();
                
                if (step.left < heights.length) {
                    const leftY = p.height - 30 - (step.leftMax / maxHeight) * (p.height - 60);
                    p.line(barWidth, leftY, p.width - barWidth, leftY);
                    
                    // Draw left max label
                    p.noStroke();
                    p.fill(120, 100, 50);
                    p.text(`Left Max: ${step.leftMax}`, barWidth * 2, leftY - 5);
                }
                
                if (step.right < heights.length) {
                    const rightY = p.height - 30 - (step.rightMax / maxHeight) * (p.height - 60);
                    p.stroke(0, 100, 50);
                    p.line(barWidth, rightY, p.width - barWidth, rightY);
                    
                    // Draw right max label
                    p.noStroke();
                    p.fill(0, 100, 50);
                    p.text(`Right Max: ${step.rightMax}`, p.width - barWidth * 2, rightY - 5);
                }
                
                // Draw trapped water total
                p.noStroke();
                p.fill(220, 80, 70);
                p.textSize(18);
                p.text(`Trapped Water: ${step.trappedWater} units`, p.width/2, 30);
                p.textSize(14);
            };
            
            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, 300);
                barWidth = p.width / (heights.length + 2);
            };
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            initVisualization();
            updateButtons();
        });
    </script>
</body>
</html>