<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Two Sum — Dry Run Visualizer (p5.js)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    :root {
      --bg: #071019;
      --panel: #0b1520;
      --accent: #7fffd4;
      --muted: #7a8b94;
      --mono: 'Fira Mono', 'Courier New', monospace;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #041018 0%, #071019 60%);
      font-family: Inter, system-ui, -apple-system, sans-serif;
      color: var(--accent);
      overflow: hidden;
    }
    
    #canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100vh;
    }
    
    .controls-overlay {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      align-items: center;
      background: rgba(7, 16, 25, 0.9);
      padding: 16px 24px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }
    
    .btn {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 10px 16px;
      border-radius: 8px;
      color: var(--accent);
      cursor: pointer;
      font-family: var(--mono);
      font-weight: 700;
      font-size: 13px;
      transition: all 0.2s;
    }
    
    .btn.primary {
      background: #002c2a1a;
      border: 1px solid rgba(127, 255, 212, 0.12);
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(127, 255, 212, 0.1);
    }
    
    input {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: transparent;
      color: var(--accent);
      font-family: var(--mono);
      font-size: 13px;
    }
    
    input:focus {
      outline: none;
      border-color: rgba(127, 255, 212, 0.2);
    }
    
    label {
      font-family: var(--mono);
      font-size: 13px;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div class="controls-overlay">
    <label>Input:</label>
    <input id="inputNums" value="2,7,11,15" style="width: 140px;" />
    <label>Target:</label>
    <input id="inputTarget" value="9" style="width: 60px;" />
    <button class="btn" id="applyBtn">Apply</button>
    <div style="width: 1px; height: 30px; background: rgba(255,255,255,0.1); margin: 0 8px;"></div>
    <button class="btn primary" id="pauseBtn">Pause</button>
    <button class="btn" id="stepBtn">Step</button>
    <button class="btn" id="resetBtn">Reset</button>
  </div>

  <script>
    // State variables
    let nums = [2, 7, 11, 15];
    let target = 9;
    let currentIndex = 0;
    let hashMap = new Map();
    let running = true;
    let stepMode = false;
    let lastStepTime = 0;
    let stepDelay = 2500;
    let animationPhase = 0; // 0: check complement, 1: show result/add to map
    let phaseStartTime = 0;
    let foundIndices = null;
    let statusMessage = "Ready. Playing dry run...";
    let currentLine = [2, 3, 4];
    
    // UI positions and dimensions
    let canvasWidth = 1400;
    let canvasHeight = 800;
    
    // Fonts
    let monoFont;
    
    function setup() {
      let canvas = createCanvas(canvasWidth, canvasHeight);
      canvas.parent('canvas-container');
      textFont('monospace');
      
      // Setup button handlers
      document.getElementById('pauseBtn').addEventListener('click', togglePause);
      document.getElementById('stepBtn').addEventListener('click', doStep);
      document.getElementById('applyBtn').addEventListener('click', applyInputs);
      document.getElementById('resetBtn').addEventListener('click', resetState);
      
      phaseStartTime = millis();
    }
    
    function draw() {
      background(7, 16, 25);
      
      // Auto-step logic
      if (running && !stepMode && millis() - lastStepTime > stepDelay) {
        if (animationPhase === 0) {
          animationPhase = 1;
          phaseStartTime = millis();
        } else {
          executeStep();
          animationPhase = 0;
          phaseStartTime = millis();
          lastStepTime = millis();
        }
      }
      
      // Draw title
      drawTitle();
      
      // Draw array visualization
      drawArray();
      
      // Draw hashmap
      drawHashMap();
      
      // Draw code
      drawCode();
      
      // Draw status message
      drawStatus();
      
      // Draw target display
      drawTarget();
    }
    
    function drawTitle() {
      fill(127, 255, 212);
      textSize(24);
      textAlign(LEFT);
      text("⌘ Two Sum — Dry run visualizer", 80, 60);
      
      fill(122, 139, 148);
      textSize(14);
      text("(p5.js version)", 400, 60);
      
      textSize(13);
      text("Find two indices i, j so that nums[i] + nums[j] = target", 80, 85);
    }
    
    function drawArray() {
      push();
      translate(80, 140);
      
      // Array label
      fill(122, 139, 148);
      textSize(13);
      textAlign(LEFT);
      text("Array (nums)", 0, 0);
      
      // Draw index row
      translate(0, 25);
      for (let i = 0; i < nums.length; i++) {
        push();
        translate(i * 80, 0);
        
        // Index cell
        fill(11, 21, 32, 100);
        stroke(255, 255, 255, 10);
        strokeWeight(1);
        rect(0, 0, 70, 30, 6);
        
        fill(122, 139, 148);
        noStroke();
        textSize(12);
        textAlign(CENTER, CENTER);
        text(i, 35, 15);
        
        pop();
      }
      
      // Draw value row
      translate(0, 40);
      for (let i = 0; i < nums.length; i++) {
        push();
        translate(i * 80, 0);
        
        // Determine cell color
        let isHighlight = i === currentIndex && !foundIndices;
        let isFound = foundIndices && (i === foundIndices[0] || i === foundIndices[1]);
        
        if (isFound) {
          fill(26, 61, 89, 200);
          stroke(255, 255, 255, 20);
        } else if (isHighlight) {
          fill(0, 59, 47, 100);
          stroke(0, 91, 69, 200);
        } else {
          fill(255, 255, 255, 5);
          stroke(255, 255, 255, 8);
        }
        
        strokeWeight(1);
        rect(0, 0, 70, 70, 8);
        
        // Draw value
        fill(127, 255, 212);
        noStroke();
        textSize(20);
        textAlign(CENTER, CENTER);
        text(nums[i], 35, 35);
        
        // Animation for highlight
        if (isHighlight) {
          translate(0, -3);
        }
        
        pop();
      }
      
      pop();
    }
    
    function drawHashMap() {
      push();
      translate(80, 360);
      
      // Hashmap label
      fill(122, 139, 148);
      textSize(13);
      textAlign(LEFT);
      text("Hash map (value → index)", 0, 0);
      
      // Draw hashmap entries
      translate(0, 25);
      let x = 0;
      let y = 0;
      let maxWidth = 600;
      
      for (let [key, value] of hashMap.entries()) {
        let entryWidth = 120;
        
        if (x + entryWidth > maxWidth) {
          x = 0;
          y += 45;
        }
        
        push();
        translate(x, y);
        
        // Entry box
        fill(255, 255, 255, 5);
        stroke(255, 255, 255, 5);
        strokeWeight(1);
        drawingContext.setLineDash([4, 4]);
        rect(0, 0, entryWidth, 35, 8);
        drawingContext.setLineDash([]);
        
        // Entry text
        fill(122, 139, 148);
        noStroke();
        textSize(13);
        textAlign(CENTER, CENTER);
        text(`${key} → ${value}`, entryWidth / 2, 17);
        
        pop();
        
        x += entryWidth + 10;
      }
      
      pop();
    }
    
    function drawCode() {
      push();
      translate(770, 140);
      
      // Code background
      fill(2, 16, 24);
      stroke(255, 255, 255, 5);
      strokeWeight(1);
      rect(0, 0, 560, 400, 10);
      
      // Code lines
      let codeLines = [
        "function twoSum(nums, target) {",
        "  const map = new Map();",
        "  for (let i = 0; i < nums.length; i++) {",
        "    const complement = target - nums[i];",
        "    if (map.has(complement)) {",
        "      return [map.get(complement), i];",
        "    }",
        "    map.set(nums[i], i);",
        "  }",
        "}"
      ];
      
      translate(15, 20);
      for (let i = 0; i < codeLines.length; i++) {
        push();
        
        // Highlight active lines
        if (currentLine.includes(i)) {
          fill(0, 59, 47, 100);
          noStroke();
          rect(-5, i * 35 - 5, 550, 30, 6);
        }
        
        fill(191, 238, 238);
        if (currentLine.includes(i)) {
          fill(223, 255, 255);
        }
        noStroke();
        textSize(13);
        textAlign(LEFT, TOP);
        text(codeLines[i], 0, i * 35);
        
        pop();
      }
      
      pop();
    }
    
    function drawStatus() {
      push();
      translate(80, 510);
      
      // Status box
      fill(5, 20, 23);
      stroke(255, 255, 255, 5);
      strokeWeight(1);
      rect(0, 0, 650, 80, 8);
      
      // Status text
      fill(122, 139, 148);
      noStroke();
      textSize(13);
      textAlign(LEFT, TOP);
      
      // Word wrap
      let words = statusMessage.split(' ');
      let line = '';
      let y = 20;
      for (let word of words) {
        let testLine = line + word + ' ';
        if (textWidth(testLine) > 610 && line !== '') {
          text(line, 20, y);
          line = word + ' ';
          y += 20;
        } else {
          line = testLine;
        }
      }
      text(line, 20, y);
      
      pop();
    }
    
    function drawTarget() {
      push();
      translate(770, 560);
      
      fill(122, 139, 148);
      textSize(13);
      textAlign(LEFT);
      text(`Target: ${target}`, 0, 0);
      
      pop();
    }
    
    function executeStep() {
      if (currentIndex >= nums.length) {
        statusMessage = "Reached end. No pair found.";
        running = false;
        currentLine = [];
        return;
      }
      
      let cur = nums[currentIndex];
      let complement = target - cur;
      
      if (animationPhase === 0) {
        statusMessage = `i = ${currentIndex}, nums[i] = ${cur}. Checking if complement ${complement} exists in map...`;
        currentLine = [2, 3, 4];
      } else {
        if (hashMap.has(complement)) {
          statusMessage = `FOUND! map has ${complement} at index ${hashMap.get(complement)}. Returning [${hashMap.get(complement)}, ${currentIndex}]`;
          foundIndices = [hashMap.get(complement), currentIndex];
          currentLine = [4, 5];
          running = false;
        } else {
          statusMessage = `${complement} not found. Inserting nums[i]=${cur} → index ${currentIndex} into map.`;
          hashMap.set(cur, currentIndex);
          currentLine = [7];
          currentIndex++;
        }
      }
    }
    
    function togglePause() {
      let btn = document.getElementById('pauseBtn');
      if (running) {
        running = false;
        btn.textContent = 'Resume';
        statusMessage = 'Paused.';
      } else {
        running = true;
        btn.textContent = 'Pause';
        statusMessage = 'Resumed.';
        lastStepTime = millis();
      }
    }
    
    function doStep() {
      if (running) {
        stepMode = true;
      }
      
      if (animationPhase === 0) {
        animationPhase = 1;
        phaseStartTime = millis();
      } else {
        executeStep();
        animationPhase = 0;
        phaseStartTime = millis();
      }
      
      if (stepMode) {
        running = false;
        stepMode = false;
        document.getElementById('pauseBtn').textContent = 'Resume';
      }
    }
    
    function applyInputs() {
      let inputNums = document.getElementById('inputNums');
      let inputTarget = document.getElementById('inputTarget');
      
      let parsed = inputNums.value.split(',').map(s => parseInt(s.trim())).filter(x => !isNaN(x));
      if (parsed.length === 0) return;
      
      nums = parsed;
      target = parseInt(inputTarget.value) || 0;
      
      resetState();
      statusMessage = 'Inputs applied. Starting dry run.';
    }
    
    function resetState() {
      currentIndex = 0;
      hashMap = new Map();
      running = true;
      stepMode = false;
      animationPhase = 0;
      foundIndices = null;
      statusMessage = "Ready. Playing dry run...";
      currentLine = [2, 3, 4];
      lastStepTime = millis();
      phaseStartTime = millis();
      document.getElementById('pauseBtn').textContent = 'Pause';
    }
  </script>
</body>
</html>
