<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alien Dictionary Dry Run (p5)</title>
  <!-- p5.js CDN with correct SRI hash. Previous integrity mismatch blocked the script, causing 'p5 is not defined'. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js" integrity="sha512-bcfltY+lNLlNxz38yBBm/HLaUB1gTV6I0e+fahbF9pS6roIdzUytozWdnFV8ZnM6cSAG5EbmO0ag0a/fLZSG4Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    :root {
      --bg: #111418;
      --panel: #1c2228;
      --accent: #ffb347; /* warm like Visualgo node highlights */
      --accent2: #6ad1ff; /* cyan for secondary emphasis */
      --accent3: #7bffb9; /* green mint */
      --danger: #ff5f56;
      --text: #d9e1e8;
      --border-radius: 10px;
      --transition: 0.25s ease;
    }
    * { box-sizing: border-box; margin:0; padding:0; }
  body { font-family: system-ui, "Segoe UI", Roboto, Arial; background: var(--bg); color: var(--text); display:flex; flex-direction:column; min-height:100vh; }
    header { padding: .75rem 1.25rem; background:#0d1013; letter-spacing:.5px; font-size: .95rem; display:flex; align-items:center; gap:.75rem; flex-wrap:wrap; border-bottom:1px solid #222; }
    header h1 { font-size:1.05rem; font-weight:600; margin-right:1rem; }
    .layout { flex:1; display:grid; grid-template-columns: 280px 1fr 320px; gap:12px; padding:12px; }
    @media (max-width:1150px){ .layout{ grid-template-columns: 240px 1fr 260px; } }
    @media (max-width:980px){ .layout{ grid-template-columns: 1fr; grid-template-rows:auto min(50vh,420px) auto; } #canvasWrap{ order:2; } #leftPanel{ order:1; } #rightPanel{ order:3; } }
    /* Portrait optimization: stack panels vertically, shrink fonts slightly, reduce padding to minimize scroll */
    @media (orientation: portrait) and (max-width:900px){
      body { overflow-y:auto; }
      header { padding:.6rem .9rem; }
      .layout { padding:8px; gap:8px; grid-template-columns:1fr; grid-template-rows:auto min(48vh,400px) auto; }
      .panel { padding:.65rem .7rem .75rem; }
      .panel h2 { font-size:.8rem; }
      .steps li { padding:.35rem .5rem; }
      .sequence { gap:.3rem; }
      .nodeBox { width:30px; height:30px; font-size:.7rem; }
      #graphCanvas canvas { max-height:400px; }
      footer { font-size:.55rem; }
    }
    .panel { background: var(--panel); border:1px solid #252c33; border-radius: var(--border-radius); padding: .9rem .95rem 1.05rem; display:flex; flex-direction:column; gap:.65rem; position:relative; }
    .panel h2 { font-size:.9rem; font-weight:600; text-transform:uppercase; letter-spacing:.75px; color: var(--accent2); }
    .small { font-size:.7rem; opacity:.7; }
    #canvasWrap { position:relative; display:flex; align-items:center; justify-content:center; }
    #graphCanvas { width:100%; height:100%; }
    /* Landscape: ensure graphCanvas flexes to occupy full panel height */
    @media (min-width:981px){
      #canvasWrap { display:flex; flex-direction:column; }
      #graphCanvas { flex:1 1 auto; height:100%; min-height:0; }
      #graphCanvas canvas { width:100%!important; height:100%!important; display:block; }
    }

    /* Controls */
    .controls { display:flex; flex-wrap:wrap; gap:.6rem; }
    button, input[type="text"], select { font: inherit; }
    button { background:#222b31; color:var(--text); border:1px solid #2f3b44; padding:.55rem .85rem; border-radius:6px; cursor:pointer; font-size:.8rem; letter-spacing:.5px; font-weight:600; display:inline-flex; align-items:center; gap:.4rem; transition: var(--transition); }
    button.primary { background:linear-gradient(135deg,#ffb347,#ff7b72); border-color:#ff9961; color:#101214; }
    button.primary:hover { filter:brightness(1.08); }
    button.outline { background:#1c242b; }
    button.outline:hover { background:#263038; }
    button:disabled { opacity:.35; cursor:not-allowed; }
    .speedWrap { display:flex; align-items:center; gap:.55rem; font-size:.7rem; }
    .speedWrap input { width:110px; }
    .inputRow { display:flex; gap:.5rem; }
    .inputRow input { flex:1; background:#20282e; border:1px solid #2e3941; padding:.5rem .6rem; border-radius:6px; color:var(--text); font-size:.75rem; }
    .badge { display:inline-block; padding:.2rem .45rem; border-radius:4px; background:#202b32; font-size:.65rem; margin:.15rem .25rem .15rem 0; }

    /* Step list */
    .steps { list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:.4rem; font-size:.7rem; }
    .steps li { padding:.4rem .55rem; border:1px solid #2a353d; border-radius:5px; background:#1e262c; line-height:1.15; position:relative; }
    .steps li.active { border-color: var(--accent); background:#262f35; }
    .steps li.done { opacity:.55; }
    .steps li::before { content:""; position:absolute; left:0; top:0; bottom:0; width:3px; border-radius:3px 0 0 3px; background:#2a353d; }
    .steps li.active::before { background:var(--accent); }

    /* Tables */
    table { width:100%; border-collapse:collapse; font-size:.7rem; }
    th, td { padding:.35rem .45rem; text-align:left; border-bottom:1px solid #263138; }
    th { font-weight:600; color:var(--accent2); }
    tbody tr.highlight td { background:#273038; }

    /* Queue & Result */
    .sequence { display:flex; flex-wrap:wrap; gap:.4rem; min-height:38px; }
    .nodeBox { width:34px; height:34px; border-radius:50%; background:linear-gradient(145deg,#27333b,#1d242a); border:2px solid #3a4a55; display:flex; align-items:center; justify-content:center; font-weight:600; font-size:.8rem; position:relative; color:var(--text); transition:var(--transition); }
    .nodeBox.edgeNew { border-color: var(--accent); box-shadow:0 0 0 2px rgba(255,179,71,.25); }
    .nodeBox.enqueued { border-color: var(--accent2); }
    .nodeBox.processed { border-color: var(--accent3); background:linear-gradient(135deg,#7bffb9 0%, #41c9a1 100%); color:#0d1316; }
    .arrowSpacer { width:10px; height:34px; position:relative; }
    .arrowSpacer:after { content:""; position:absolute; left:50%; top:50%; width:14px; height:2px; background:#42525d; transform:translate(-50%,-50%); }

    /* Legend */
    .legend { display:flex; flex-wrap:wrap; gap:.6rem; font-size:.6rem; }
    .legend span { display:inline-flex; align-items:center; gap:.35rem; }
    .legend i { width:14px; height:14px; border-radius:50%; display:inline-block; }
    .l-new i { background:var(--accent); }
    .l-queue i { background:var(--accent2); }
    .l-done i { background:var(--accent3); }

  /* Edge derivation detail */
  .derivation-table { width:100%; border-collapse:collapse; font-size:.65rem; margin-top:.25rem; }
  .derivation-table th, .derivation-table td { padding:.3rem .4rem; border-bottom:1px solid #263138; }
  .derivation-table th { color:var(--accent2); font-weight:600; }
  .derivation-table tr.current td { background:#2a353d; }
  .derivation-table tr.completed td { opacity:.6; }
  .derivation-table code { background:#202b32; padding:0 .25rem; border-radius:3px; }

    footer { padding:.5rem .9rem; font-size:.6rem; letter-spacing:.5px; background:#0d1013; border-top:1px solid #222; display:flex; flex-wrap:wrap; align-items:center; gap:.6rem; }
    code { background:#20282e; padding:.15rem .3rem; border-radius:4px; font-size:.65rem; }
  </style>
</head>
<body>
  <header>
    <h1>Alien Dictionary • Dry Run Visualizer (p5.js)</h1>
    <div class="inputRow" style="flex:1; max-width:520px;">
      <input id="wordsInput" placeholder='Enter words comma-separated (e.g. wrt, wrf, er, ett, rftt)' />
      <button id="loadBtn" class="outline" title="Load words">Load</button>
    </div>
    <div class="controls">
      <button id="playBtn" class="primary" title="Play / Pause">Play</button>
      <button id="stepBtn" class="outline" title="Advance one step">Step</button>
      <button id="resetBtn" class="outline" title="Reset visualization">Reset</button>
      <div class="speedWrap">
        <label for="speedRange">Speed</label>
        <input id="speedRange" type="range" min="0.25" max="2" step="0.25" value="1" />
      </div>
    </div>
  </header>

  <div class="layout">
    <!-- Left panel: Steps & Edge Extraction -->
    <section id="leftPanel" class="panel">
      <h2>Steps</h2>
      <ul id="stepsList" class="steps"></ul>
      <h2 style="margin-top:.4rem;">Derived Edges</h2>
      <div id="edgesList" style="min-height:70px; font-size:.7rem; line-height:1.2;"></div>
  <h2 style="margin-top:.4rem;">Derivation Detail</h2>
  <div id="edgeDerivationDetail" style="max-height:140px; overflow:auto;"></div>
      <h2 style="margin-top:.4rem;">Characters</h2>
      <div id="charsList" style="display:flex; flex-wrap:wrap;"></div>
    </section>

    <!-- Center panel: Graph Canvas -->
    <section id="canvasWrap" class="panel">
      <h2 style="position:absolute; left:12px; top:10px;">Graph</h2>
      <div id="graphCanvas"></div>
    </section>

    <!-- Right panel: In-Degree / Queue / Result -->
    <section id="rightPanel" class="panel">
      <h2>In-Degree</h2>
      <div style="overflow:auto; max-height:140px;">
        <table id="indegreeTable"><thead><tr><th>Char</th><th>In</th></tr></thead><tbody></tbody></table>
      </div>
      <h2 style="margin-top:.4rem;">Queue</h2>
      <div id="queueSeq" class="sequence"></div>
      <h2 style="margin-top:.4rem;">Result Order</h2>
      <div id="resultSeq" class="sequence"></div>
      <div class="legend" style="margin-top:.6rem;">
        <span class="l-new"><i></i> new edge</span>
        <span class="l-queue"><i></i> in queue</span>
        <span class="l-done"><i></i> processed</span>
      </div>
    </section>
  </div>

  <footer>
    <span>Algorithm: Build graph from first differing chars, compute in-degrees, BFS (topological sort).</span>
  </footer>

  <!-- Visualization Script -->
  <script>
    /*
      Alien Dictionary Visualizer (Inline)
      - Focus: Educational animation sequence.
      - States:
        0 Extract unique characters
        1 Compare adjacent words & derive edges (animated sequentially)
        2 Compute in-degrees table
        3 Initialize queue (in-degree = 0)
        4 Process queue (topological sort BFS) step-by-step
        5 Finished (display final order)
      - Additional manual stepping: User can pause and Step.
    */

  // More illustrative default test case showing branching and multiple dependencies.
  // Example from common explanations: expected order b d a c
  // Edges derived:
  //   "baa" vs "abcd" -> b -> a
  //   "abcd" vs "abca" -> d -> a
  //   "abca" vs "cab"  -> a -> c
  //   "cab"  vs "cad"  -> b -> d (already have b->d implicit via chain)
  const DEFAULT_WORDS = ["baa","abcd","abca","cab","cad"]; // expected order: bdac

    const state = {
      words: [...DEFAULT_WORDS],
      chars: [],
      edges: [], // {from,to}
      edgeDerivations: [], // {w1,w2,edge}
      graph: {},
      indegree: {},
      queue: [],
      result: [],
      phase: 0,
      playing: true,
      speed: 1,
      tick: 0,
      subIndex: 0, // for edge derivation / queue processing granularity
      canvas: null,
      layoutPositions: {},
      queuedSet: new Set(),
      processedSet: new Set(),
      justAddedEdge: null,
      lastActionTick: 0
    };

    const PHASE_LABELS = [
      "Collect Characters",
      "Derive Edges",
      "Compute In-Degrees",
      "Init Queue",
      "Process Queue (BFS)",
      "Done"
    ];

    function initWords(list){
      state.words = list.map(w => w.trim()).filter(w => w.length);
      if(!state.words.length) state.words = [...DEFAULT_WORDS];
      resetState();
      buildStepsUI();
    }

    function resetState(){
      state.phase = 0; state.edges = []; state.edgeDerivations = []; state.graph = {}; state.indegree = {}; state.queue = []; state.result = []; state.processedSet.clear(); state.queuedSet.clear(); state.justAddedEdge = null; state.subIndex = 0; state.tick=0; state.lastActionTick=0;
      // phase 0: collect chars
      const charsSet = new Set();
      state.words.forEach(w => { for(const c of w) charsSet.add(c); });
      state.chars = [...charsSet];
      state.chars.sort();
      updateCharsPanel();
      updateIndegreeTable();
      updateQueueResultPanels();
      computeLayoutPositions();
      highlightSteps();
      renderEdgesList();
      renderEdgeDerivationDetail();
    }

    function deriveNextEdge(){
      // sequentially compare adjacent words; stop after first diff
      if(state.subIndex >= state.words.length - 1){ // done deriving edges
        state.phase = 2; state.subIndex = 0; computeIndegrees(); highlightSteps(); return; }
      const w1 = state.words[state.subIndex];
      const w2 = state.words[state.subIndex+1];
      let found = null;
      for(let i=0;i<Math.min(w1.length,w2.length);i++){ if(w1[i]!==w2[i]) { found={from:w1[i],to:w2[i]}; break; } }
      if(found){
        // add edge if not already
        if(!state.edges.some(e=>e.from===found.from && e.to===found.to)){
          state.edges.push(found); state.justAddedEdge = found; buildGraph(); renderEdgesList(); }
      }
      state.edgeDerivations.push({ w1, w2, edge: found });
      state.subIndex++;
      renderEdgeDerivationDetail();
    }

    function buildGraph(){
      state.graph={}; state.chars.forEach(c=> state.graph[c] = []);
      state.edges.forEach(e=> { if(!state.graph[e.from].includes(e.to)) state.graph[e.from].push(e.to); });
    }

    function computeIndegrees(){
      state.indegree={}; state.chars.forEach(c=> state.indegree[c]=0);
      state.edges.forEach(e=> state.indegree[e.to]++);
      updateIndegreeTable();
    }

    function initQueue(){
      state.queue = state.chars.filter(c=> state.indegree[c]===0);
      state.queue.forEach(c=> state.queuedSet.add(c));
      updateQueueResultPanels();
    }

    function processQueueStep(){
      if(!state.queue.length){ // finished processing
        state.phase = 5; highlightSteps(); return; }
      const c = state.queue.shift();
      state.result.push(c); state.processedSet.add(c); state.queuedSet.delete(c);
      for(const nei of state.graph[c]){ state.indegree[nei]--; if(state.indegree[nei]===0){ state.queue.push(nei); state.queuedSet.add(nei); } }
      updateIndegreeTable(); updateQueueResultPanels();
    }

    function advancePhaseLogic(){
      switch(state.phase){
        case 0: // after short delay, move to deriving edges
          state.phase = 1; highlightSteps(); break;
        case 1: deriveNextEdge(); break;
        case 2: // show indegree stable then move
          state.phase = 3; highlightSteps(); initQueue(); break;
        case 3: // after visible queue, start processing
          state.phase = 4; highlightSteps(); break;
        case 4: processQueueStep(); break;
      }
    }

    // UI Building -------------------------------------------------------
    function buildStepsUI(){
      const ul = document.getElementById('stepsList'); ul.innerHTML='';
      PHASE_LABELS.forEach((l,i)=>{ const li=document.createElement('li'); li.dataset.phase=i; li.textContent= (i+1)+'. '+l; ul.appendChild(li); });
      highlightSteps();
    }
    function highlightSteps(){
      document.querySelectorAll('#stepsList li').forEach(li=>{
        const p = parseInt(li.dataset.phase); li.classList.remove('active','done');
        if(p < state.phase) li.classList.add('done'); else if(p===state.phase) li.classList.add('active');
      });
    }
    function renderEdgesList(){
      const div=document.getElementById('edgesList');
      if(!state.edges.length){ div.innerHTML='<span class="small" style="opacity:.6;">(none yet)</span>'; return; }
      div.innerHTML = state.edges.map(e=> `<span class='badge'>${e.from} → ${e.to}</span>`).join('');
    }
    function renderEdgeDerivationDetail(){
      const wrap = document.getElementById('edgeDerivationDetail');
      if(!wrap) return;
      if(!state.edgeDerivations.length){ wrap.innerHTML = '<span class="small" style="opacity:.6;">(no comparisons yet)</span>'; return; }
      let html = '<table class="derivation-table"><thead><tr><th>#</th><th>Pair</th><th>First diff</th><th>Edge</th></tr></thead><tbody>';
      state.edgeDerivations.forEach((d,i)=>{
        const diff = d.edge ? `<code>${d.edge.from}</code> vs <code>${d.edge.to}</code>` : '<span style="opacity:.5;">none</span>';
        const edgeTxt = d.edge ? `<strong>${d.edge.from} → ${d.edge.to}</strong>` : '<span style="opacity:.45;">—</span>';
        const rowClass = (state.phase===1 && i===state.edgeDerivations.length-1 && state.subIndex < state.words.length-1) ? 'current' : (i < state.edgeDerivations.length ? 'completed' : '');
        html += `<tr class='${rowClass}'><td>${i+1}</td><td><code>${d.w1}</code> / <code>${d.w2}</code></td><td>${diff}</td><td>${edgeTxt}</td></tr>`;
      });
      html += '</tbody></table>';
      wrap.innerHTML = html;
    }
    function updateCharsPanel(){
      const div=document.getElementById('charsList'); div.innerHTML='';
      state.chars.forEach(c=>{ const el=document.createElement('span'); el.className='badge'; el.textContent=c; div.appendChild(el); });
    }
    function updateIndegreeTable(){
      const tbody=document.querySelector('#indegreeTable tbody'); tbody.innerHTML='';
      state.chars.forEach(c=>{ const tr=document.createElement('tr'); if(state.justAddedEdge && state.justAddedEdge.to===c) tr.classList.add('highlight');
        tr.innerHTML=`<td>${c}</td><td>${state.indegree[c]??0}</td>`; tbody.appendChild(tr); });
    }
    function updateQueueResultPanels(){
      const qDiv=document.getElementById('queueSeq'); qDiv.innerHTML='';
      state.queue.forEach(c=>{ const box=document.createElement('div'); box.className='nodeBox enqueued'; box.textContent=c; qDiv.appendChild(box); });
      const rDiv=document.getElementById('resultSeq'); rDiv.innerHTML='';
      state.result.forEach((c,i)=>{ const box=document.createElement('div'); box.className='nodeBox processed'; box.textContent=c; rDiv.appendChild(box); if(i < state.result.length-1){ const spacer=document.createElement('div'); spacer.className='arrowSpacer'; rDiv.appendChild(spacer); } });
    }

    // p5 Sketch ----------------------------------------------------------
    let sketch = (p)=>{
      p.setup = function(){
        const wrap=document.getElementById('graphCanvas');
        const c=p.createCanvas(wrap.clientWidth, wrap.clientHeight);
        c.parent('graphCanvas');
        p.textFont('Segoe UI'); p.textAlign(p.CENTER,p.CENTER);
        // Defer a resize one frame later to capture final flex height in landscape.
        setTimeout(()=>{ const w=document.getElementById('graphCanvas'); p.resizeCanvas(w.clientWidth, w.clientHeight); computeLayoutPositions(); }, 50);
      }
      p.windowResized = function(){ const wrap=document.getElementById('graphCanvas'); p.resizeCanvas(wrap.clientWidth, wrap.clientHeight); computeLayoutPositions(); }
      p.draw = function(){ p.background(28,34,40);
        if(state.playing){ state.tick += state.speed; if(state.tick - state.lastActionTick > 50 / state.speed){ state.lastActionTick = state.tick; advancePhaseLogic(); } }
        drawGraph(p);
        // subtle pulse for recently added edge
        if(state.justAddedEdge && state.tick - state.lastActionTick > 25){ state.justAddedEdge = null; updateIndegreeTable(); }
      }
    };
    new p5(sketch);

    function computeLayoutPositions(){
      // Radial layout with vertical margins so bottom nodes don't clip outside panel in landscape.
      const W = document.getElementById('graphCanvas').clientWidth;
      const H = document.getElementById('graphCanvas').clientHeight;
      const topMargin = 50;      // space for heading
      const bottomMargin = 80;   // space for footer note
      const usableH = Math.max(100, H - topMargin - bottomMargin);
      const cx = W/2;
      const cy = topMargin + usableH/2; // center shifted down within usable vertical space
      const R = Math.min(W, usableH)/2 - 30; // radius with extra margin so circle fully visible
      state.layoutPositions={};
      state.chars.forEach((c,i)=>{ const angle = (i/state.chars.length)*Math.PI*2 - Math.PI/2; state.layoutPositions[c]={x: cx + Math.cos(angle)*R, y: cy + Math.sin(angle)*R}; });
    }

    function drawGraph(p){
      // edges
      p.strokeWeight(2);
      state.edges.forEach(e=>{ const from=state.layoutPositions[e.from]; const to=state.layoutPositions[e.to]; if(!from||!to) return; const col = (state.justAddedEdge===e)? p.color(255,179,71): p.color(106,209,255,130); p.stroke(col); drawArrow(p, from.x, from.y, to.x, to.y, col); });
      // nodes
      state.chars.forEach(c=>{ const pos=state.layoutPositions[c]; if(!pos) return; p.push();
        let baseCol = p.color(58,74,85);
        if(state.processedSet.has(c)) baseCol = p.color(123,255,185);
        else if(state.queuedSet.has(c)) baseCol = p.color(106,209,255);
        const r = 32; p.noStroke(); p.fill(29,36,42); p.circle(pos.x,pos.y,r*1.15);
        p.strokeWeight(3); p.stroke(baseCol); p.fill(29,36,42); p.circle(pos.x,pos.y,r);
        p.noStroke(); p.fill(220); p.textSize(16); p.text(c,pos.x,pos.y);
        if(state.processedSet.has(c)){ p.noFill(); p.stroke(123,255,185,140); p.circle(pos.x,pos.y,r + 6 + Math.sin(state.tick/15)*3); }
      p.pop(); });
    }

    function drawArrow(p,x1,y1,x2,y2, col){
      const angle = Math.atan2(y2-y1,x2-x1); const d = 20; const sx = x1 + Math.cos(angle)*18; const sy = y1 + Math.sin(angle)*18; const ex = x2 - Math.cos(angle)*18; const ey = y2 - Math.sin(angle)*18; p.line(sx,sy,ex,ey); // arrowhead
      p.push(); p.translate(ex,ey); p.rotate(angle); p.noStroke(); p.fill(col); p.triangle(0,0,-8,-4,-8,4); p.pop();
    }

    // Event Listeners ----------------------------------------------------
    document.getElementById('loadBtn').addEventListener('click',()=>{ initWords(document.getElementById('wordsInput').value.split(',')); });
    document.getElementById('playBtn').addEventListener('click',()=>{ state.playing=!state.playing; document.getElementById('playBtn').textContent = state.playing? 'Pause':'Play'; });
    document.getElementById('stepBtn').addEventListener('click',()=>{ if(state.playing) return; advancePhaseLogic(); });
    document.getElementById('resetBtn').addEventListener('click',()=>{ resetState(); document.getElementById('playBtn').textContent='Pause'; state.playing=true; });
    document.getElementById('speedRange').addEventListener('input',e=>{ state.speed = parseFloat(e.target.value); });

    // Initialize on load
    buildStepsUI(); initWords(DEFAULT_WORDS); document.getElementById('wordsInput').value = DEFAULT_WORDS.join(',');
  </script>
</body>
</html>